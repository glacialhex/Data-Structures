//insertt checkkk hbubbnkk
// RadixTree.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

// RadixTree.cpp : This file contains the 'main' function. Program execution begins and ends there.
//
#include <cstring>
#include "RadixTree.h"

	RadixTree::RadixTree(){
		myRoot = nullptr;
	}
	RadixTree::~RadixTree() {
		//deletion 
	}

	bool RadixTree::empty(){
		return childCount == 0;

	}
	int RadixTree::SearchPrefix(const char& word, Node* currectNode) {
		int i = 0;
		while (currentNode->data[i] != '\0' && word[i] != '\0' && word[i] == currentNode->data[i])
			i++;
		return i;
	}
	void RadixTree::addchild(Node* parent, Node* childnode) {
		//created a newchild from type child so now it has firstchar, node from type node(data, bool ended, children of type child( first char, node of type node(will hv other children in it),node() and node copy constructor)) pointer next of type child do it can point on everything in child
		child* newchild = new child(childnode->data[0], childnode);//saved first char, and childnode is the node of child itselt
		newchild->next = parent->children;//siblings of new child is now the chilren of the parent
		parent->children = newchild; //children of parent is now the new child, so when saying children the pointer now points to the new child
	}
	void RadixTree::insert(const char* word) {
		//case1:empty tree
		if (empty()) {
			myRoot = new Node(word);
			myRoot->ended = true;
			return;
		}
		//case 3:common  prefix found
		child* cur = myRoot->children;
		bool foundPrefix = false;
		Node* current = myRoot;
		while (cur != nullptr) {
			int pref = SearchPrefix(cur->node->data, word);
			if (pref> 0) {// case exact match
				if (pref == strlen(cur->node->data) && pref == strlen(word)) {// this works becaus ethe serachprefix counts only equal prefixes so if they are same number as well then its the same word
					cur->node->ended = true;
					return;
				}
				//case word is prefix of a node
				if (pref == strlen(word) && pref < strlen(cur->node->data)) {
					Node* oldnode = cur->node;//let oldnode pointer point at the node with the whole word
					Node* newnode = new Node(word); //node created for our word 
					newnode->ended = true;
					/*char temp[50]
					strcpy(temp, oldnode->data+pref);
					strcpy(oldnode->data,temp);
					or */
					Node* suffix = new Node(oldnode->data + pref);
					suffix->ended = oldnode->ended;
					suffix->children = oldnode->children;
					newnode->children = NULL;
					addchild(newnode, suffixnode);
					cur->node = newnode;
					return;

				}
				foundPrefix = true;
				
				break;
			}
			cur = cur->next;
		}
		
	//case 2:no common prefix found
		if (!foundPrefix) {
		
			Node* newnode = new Node(word);// created a newnode pointer of type node, then made it point to a node that has the word
			newnode->ended = true;
			addchild(current,newnode);


			

	}






// Run program: Ctrl + F5 or Debug > Start Without Debugging menu
// Debug program: F5 or Debug > Start Debugging menu

// Tips for Getting Started: 
//   1. Use the Solution Explorer window to add/manage files
//   2. Use the Team Explorer window to connect to source control
//   3. Use the Output window to see build output and other messages
//   4. Use the Error List window to view errors
//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project
//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file
